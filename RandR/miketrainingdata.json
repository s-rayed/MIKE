{
  "add" : {
    "doc" : {
      "id" : 1,
      "author" : "http://eloquentjavascript.net/03_functions.html",
      "bibliography" : "Alongside HTML and CSS, it is one of the three core technologies of World Wide Web content production; the majority of websites employ it and it is supported by all modern Web browsers without plug-ins.[6] JavaScript is prototype-based with first-class functions, making it a multi-paradigm language, supporting object-oriented, imperative, and functional programming styles.",
        "body" : "JavaScript is a high-level, dynamic, untyped, and interpreted programming language. It has been standardized in the ECMAScript language specification.",
        "title" : "Javascript"
      }
    },
    "add" : {
      "doc" : {
        "id" : 2,
        "author" : "http://eloquentjavascript.net/03_functions.html",
        "bibliography" : "The parameters to a function behave like regular variables, but their initial values are given by the caller of the function, not the code in the function itself.

        An important property of functions is that the variables created inside of them, including their parameters, are local to the function. This means, for example, that the result variable in the power example will be newly created every time the function is called, and these separate incarnations do not interfere with each other.

        This 'localness' of variables applies only to the parameters and to variables declared with the var keyword inside the function body. Variables declared outside of any function are called global, because they are visible throughout the program. It is possible to access such variables from inside a function, as long as you haven’t declared a local variable with the same name.",
        "body" : "Parameters in Javascript",
        "title" : "Parameters"
      }
    },
    "add" : {
      "doc" : {
        "id" : 3,
        "author" : "http://eloquentjavascript.net/03_functions.html",
        "bibliography" : "A function definition is just a regular variable definition where the value given to the variable happens to be a function. For example, the following code defines the variable square to refer to a function that produces the square of a given number:

        var square = function(x) {
          return x * x;
        };

        console.log(square(12));
        // → 144
        A function is created by an expression that starts with the keyword function. Functions have a set of parameters (in this case, only x) and a body, which contains the statements that are to be executed when the function is called. The function body must always be wrapped in braces, even when it consists of only a single statement (as in the previous example).

        A function can have multiple parameters or no parameters at all. In the following example, makeNoise does not list any parameter names, whereas power lists two:

        var makeNoise = function() {
          console.log('Pling!');
        };

        makeNoise();
        // → Pling!

        var power = function(base, exponent) {
          var result = 1;
          for (var count = 0; count < exponent; count++)
          result *= base;
          return result;
        };

        console.log(power(2, 10));
        // → 1024",
        "body" : "Functions in Javascript",
        "title" : "Functions"
      }
    },
    "add" : {
      "doc" : {
        "id" : 4,
        "author" : "Google",
        "bibliography" : "It is perfectly okay for a function to call itself, as long as it takes care not to overflow the stack. A function that calls itself is called recursive. Recursion allows some functions to be written in a different style. This is rather close to the way mathematicians define exponentiation and arguably describes the concept in a more elegant way than the looping variant does. The function calls itself multiple times with different arguments to achieve the repeated multiplication. But this implementation has one important problem: in typical JavaScript implementations, it’s about 10 times slower than the looping version. Running through a simple loop is a lot cheaper than calling a function multiple times.",
        "body" : "Recursion in Javascript",
        "title" : "Recursion"
      }
    },
    "add" : {
      "doc" : {
        "id" : 5,
        "author" : "http://eloquentjavascript.net/04_data.html",
        "bibliography" : "Numbers, Booleans, and strings are the bricks that data structures are built from. But you can’t make much of a house out of a single brick. Objects allow us to group values—including other objects—together and thus build more complex structures. The programs we have built so far have been seriously hampered by the fact that they were operating only on simple data types. This chapter will add a basic understanding of data structures to your toolkit. By the end of it, you’ll know enough to start writing some useful programs.",
        "body" : "Data Structures in Javascript",
        "title" : "Data Structures"
      }
    },
    "add" : {
      "doc" : {
        "id" : 6,
        "author" : "http://eloquentjavascript.net/04_data.html",
        "bibliography" : "To work with a chunk of digital data, we’ll first have to find a way to represent it in our machine’s memory. Say, as a simple example, that we want to represent a collection of numbers: 2, 3, 5, 7, and 11. We could get creative with strings—after all, strings can be any length, so we can put a lot of data into them—and use '2 3 5 7 11' as our representation. But this is awkward. You’d have to somehow extract the digits and convert them back to numbers to access them. Fortunately, JavaScript provides a data type specifically for storing sequences of values. It is called an array and is written as a list of values between square brackets, separated by commas.",
        "body" : "Datasets in Javascript",
        "title" : "Datasets"
      }
    },
    "add" : {
      "doc" : {
        "id" : 7,
        "author" : "http://eloquentjavascript.net/04_data.html",
        "bibliography" : "A set of daily log entries can be represented as an array. But the entries do not consist of just a number or a string—each entry needs to store a list of activities and a Boolean value that indicates whether Jacques turned into a squirrel. Ideally, we would like to group these values together into a single value and then put these grouped values into an array of log entries. Values of the type object are arbitrary collections of properties, and we can add or remove these properties as we please. One way to create an object is by using a curly brace notation. Inside the curly braces, we can give a list of properties separated by commas. Each property is written as a name, followed by a colon, followed by an expression that provides a value for the property. Spaces and line breaks are not significant. When an object spans multiple lines, indenting it like in the previous example improves readability. Properties whose names are not valid variable names or valid numbers have to be quoted.",
        "body" : "Objects in Javascript",
        "title" : "Objects"
      }
    },
    "add" : {
      "doc" : {
        "id" : 8,
        "author" : "http://eloquentjavascript.net/04_data.html",
        "bibliography" : "Numbers, strings, and Booleans, are all immutable—it is impossible to change an existing value of those types. You can combine them and derive new values from them, but when you take a specific string value, that value will always remain the same. The text inside it cannot be changed. If you have reference to a string that contains 'cat', it is not possible for other code to change a character in that string to make it spell 'rat'. With objects, on the other hand, the content of a value can be modified by changing its properties. When we have two numbers, 120 and 120, we can consider them precisely the same number, whether or not they refer to the same physical bits. But with objects, there is a difference between having two references to the same object and having two different objects that contain the same properties. ",
        "body" : "Mutability in Javascript",
        "title" : "Mutability"
      }
    },
    "add" : {
      "doc" : {
        "id" : 9,
        "author" : "http://eloquentjavascript.net/05_higher_order.html",
        "bibliography" : "Functions that operate on other functions, either by taking them as arguments or by returning them, are called higher-order functions. If you have already accepted the fact that functions are regular values, there is nothing particularly remarkable about the fact that such functions exist. The term comes from mathematics, where the distinction between functions and other values is taken more seriously.
        function greaterThan(n) {
          return function(m) { return m > n; };
        }
        var greaterThan10 = greaterThan(10);
        console.log(greaterThan10(11));
        // → true

        Higher-order functions allow us to abstract over actions, not just values. They come in several forms. For example, you can have functions that create new functions. And you can have functions that change other functions.",
        "body" : "Higher order functions in Javascript",
        "title" : "Higher order functions"
      }
    },
    "add" : {
      "doc" : {
        "id" : 10,
        "author" : "Google",
        "bibliography" : "It is widely used as a data storage and communication format on the Web. JSON is similar to JavaScript’s way of writing arrays and objects, with a few restrictions. All property names have to be surrounded by double quotes, and only simple data expressions are allowed—no function calls, variables, or anything that involves actual computation. Comments are not allowed in JSON. JavaScript gives us functions, JSON.stringify and JSON.parse, that convert data from and to this format. The first takes a JavaScript value and returns a JSON-encoded string. The second takes such a string and converts it to the value it encodes.",
        "body" : "Pronounced 'Jason' stands for JavaScript Object Notation",
        "title" : "JSON"
      }
    },
    "add" : {
      "doc" : {
        "id" : 11,
        "author" : "Google",
        "bibliography" : "Ruby utilizes OOP to model programming problems in a real world way",
        "body" : "Object Oriented Programming",
        "title" : "OOP"
      }
    },
    "add" : {
      "doc" : {
        "id" : 12,
        "author" : "Google",
        "bibliography" : "Ruby comes with many out of the box methods, and also gives you the ability to define custom methods.",
        "body" : "Method",
        "title" : "Methods"
      }
    },
    "add" : {
      "doc" : {
        "id" : 13,
        "author" : "Google",
        "bibliography" : "Classes and class inheritance are important concepts in Ruby. They allow you to create objects with similar characteristics without having to create each on from scratch.",
        "body" : "Class",
        "title" : "Classes"
      }
    },
    "add" : {
      "doc" : {
        "id" : 14,
        "author" : "Google",
        "bibliography" : "Hashes and arrays are the core data structures in Ruby. You can use them in different ways to store any kind of data you would like.",
        "body" : "Data Structures",
        "title" : "DS"
      }
    },
    "add" : {
      "doc" : {
        "id" : 15,
        "author" : "Google",
        "bibliography" : "In Ruby, hashes use a key and value pair structure to store data. Generally keys are symbols and the value can be any Ruby object.",
        "body" : "Hashes",
        "title" : "Hash"
      }
    },
    "add" : {
      "doc" : {
        "id" : 16,
        "author" : "Google",
        "bibliography" : "In Ruby, an array is an ordered list of data that is indexed at 0.",
        "body" : "Arrays",
        "title" : "Array"
      }
    },
    "add" : {
      "doc" : {
        "id" : 17,
        "author" : "Google",
        "bibliography" : "You can use loop methods to iterate over sets of data to alter or organize the data contained.",
        "body" : "Loop",
        "title" : "Loops"
      }
    },
    "add" : {
      "doc" : {
        "id" : 18,
        "author" : "Google",
        "bibliography" : "In Ruby, you can declare a variable by naming it and putting the value after an equlas sign",
        "body" : "Variable",
        "title" : "Variables"
      }
    },
    "add" : {
      "doc" : {
        "id" : 19,
        "author" : "Google",
        "bibliography" : "Ruby, like many other languages have many tools for debugging. The most common are pry and byebug",
        "body" : "Debugging",
        "title" : "DB"
      }
    },
    "add" : {
      "doc" : {
        "id" : 20,
        "author" : "Google",
        "bibliography" : "Modules can be used to store constants and methods that don't fit into your classes in Ruby and can be easily included in your programs.",
        "body" : "Module",
        "title" : "Modules"
      }
    },
      "add" : {
        "doc" : {
          "id" : 21,
          "author" : "http://eloquentjavascript.net/05_higher_order.html",
          "bibliography" : "The reduce method is a higher-order operation (sometimes reffered to as fold). You can think of it as folding up the array, one element at a time. When summing numbers, you’d start with the number zero and, for each element, combine it with the current sum by adding the two. The parameters to the reduce function are, apart from the array, a combining function and a start value. This function is a little less straightforward than filter and map, so pay careful attention.",
          "body" : "Reduce method for arrays",
          "title" : "Reduce method"
        }
      },
      "add" : {
        "doc" : {
          "id" : 22,
          "author" : "http://eloquentjavascript.net/05_higher_order.html",
          "bibliography" : "The bind method, which all functions have, creates a new function that will call the original function but with some of the arguments already fixed.

          The following code shows an example of bind in use. It defines a function isInSet that tells us whether a person is in a given set of strings. To call filter in order to collect those person objects whose names are in a specific set, we can either write a function expression that makes a call to isInSet with our set as its first argument or partially apply the isInSet function.

          var theSet = ['Carel Haverbeke', 'Maria van Brussel',
            'Donald Duck'];
          function isInSet(set, person) {
            return set.indexOf(person.name) > -1;
          }

          console.log(ancestry.filter(function(person) {
            return isInSet(theSet, person);
          }));
          // → [{name: 'Maria van Brussel', …},
            //    {name: 'Carel Haverbeke', …}]
          console.log(ancestry.filter(isInSet.bind(null, theSet)));
          // → … same result
          The call to bind returns a function that will call isInSet with theSet as first argument, followed by any remaining arguments given to the bound function.

          The first argument, where the example passes null, is used for method calls, similar to the first argument to apply. I’ll describe this in more detail in the next chapter.",
          "body" : "Binding in Javascript",
          "title" : "binding"
        }
      },
      "add" : {
        "doc" : {
          "id" : 23,
          "author" : "http://eloquentjavascript.net/06_object.html",
          "bibliography" : "In addition to their set of properties, almost all objects also have a prototype. A prototype is another object that is used as a fallback source of properties. When an object gets a request for a property that it does not have, its prototype will be searched for the property, then the prototype’s prototype, and so on. So who is the prototype of that empty object? It is the great ancestral prototype, the entity behind almost all objects, Object.prototype. As you might expect, the Object.getPrototypeOf function returns the prototype of an object. The prototype relations of JavaScript objects form a tree-shaped structure, and at the root of this structure sits Object.prototype. It provides a few methods that show up in all objects, such as toString, which converts an object to a string representation.",
          "body" : "Prototype of an object in JavaScript",
          "title" : "prototype of an object"
        }
      },
      "add" : {
        "doc" : {
          "id" : 24,
          "author" : "http://eloquentjavascript.net/06_object.html",
          "bibliography" : "A more convenient way to create objects that derive from some shared prototype is to use a constructor. In JavaScript, calling a function with the new keyword in front of it causes it to be treated as a constructor. The constructor will have its this variable bound to a fresh object, and unless it explicitly returns another object value, this new object will be returned from the call.

          An object created with new is said to be an instance of its constructor.

          Here is a simple constructor for rabbits. It is a convention to capitalize the names of constructors so that they are easily distinguished from other functions.

          function Rabbit(type) {
            this.type = type;
          }

          var killerRabbit = new Rabbit('killer');
          var blackRabbit = new Rabbit('black');
          console.log(blackRabbit.type);
          // → black
          Constructors (in fact, all functions) automatically get a property named prototype, which by default holds a plain, empty object that derives from Object.prototype.",
          "body" : "constructors of objects",
          "title" : "constructors"
        }
      },
      "add" : {
        "doc" : {
          "id" : 25,
          "author" : "http://eloquentjavascript.net/06_object.html",
          "bibliography" : "A prototype can be used at any time to add new properties and methods to all objects based on it. For example, it might become necessary for our rabbits to dance.

          Rabbit.prototype.dance = function() {
            console.log('The ' + this.type + ' rabbit dances a jig.');
          };
          killerRabbit.dance();
          // → The killer rabbit dances a jig.
          That’s convenient. But there are situations where it causes problems. In previous chapters, we used an object as a way to associate values with names by creating properties for the names and giving them the corresponding value as their value.",
          "body" : "prototype interference in objects",
          "title" : "prototype interference"
        }
      },
      "add" : {
        "doc" : {
          "id" : 26,
          "author" : "http://eloquentjavascript.net/03_functions.html",
          "bibliography" : "The ability to treat functions as values, combined with the fact that local variables are 're-created' every time a function is called, brings up an interesting question. What happens to local variables when the function call that created them is no longer active?",
          "body" : "Closure in Javascript",
          "title" : "Closure"
        }
      },
      "add" : {
        "doc" : {
          "id" : 27,
          "author" : "http://eloquentjavascript.net/09_regexp.html",
          "bibliography" : "A regular expression is a type of object. It can either be constructed with the RegExp constructor or written as a literal value by enclosing the pattern in forward slash (/) characters. When using the RegExp constructor, the pattern is written as a normal string, so the usual rules apply for backslashes. The second notation, where the pattern appears between slash characters, treats backslashes somewhat differently. First, since a forward slash ends the pattern, we need to put a backslash before any forward slash that we want to be part of the pattern. In addition, backslashes that aren’t part of special character codes (like \n) will be preserved, rather than ignored as they are in strings, and change the meaning of the pattern. Some characters, such as question marks and plus signs, have special meanings in regular expressions and must be preceded by a backslash if they are meant to represent the character itself.",
          "body" : "Regular Expression",
          "title" : "Regex"
        }
      },
      "add" : {
        "doc" : {
          "id" : 28,
          "author" : "http://eloquentjavascript.net/10_modules.html",
          "bibliography" : "When looking at a larger program in its entirety, individual functions start to blend into the background. Such a program can be made more readable if we have a larger unit of organization. Modules divide programs into clusters of code that, by some criterion, belong together. This chapter explores some of the benefits that such division provides and shows techniques for building modules in JavaScript.",
          "body" : "Modules in Javascript",
          "title" : "Modules"
        }
      },
      "add" : {
        "doc" : {
          "id" : 29,
          "author" : "http://eloquentjavascript.net/10_modules.html",
          "bibliography" : "Most modern programming languages have a scope level between global (everyone can see it) and local (only this function can see it). JavaScript does not. Thus, by default, everything that needs to be visible outside of the scope of a top-level function is visible everywhere. Namespace pollution, the problem of a lot of unrelated code having to share a single set of global variable names, was mentioned in Chapter 4, where the Math object was given as an example of an object that acts like a module by grouping math-related functionality.",
          "body" : "Namespacing in Javascript",
          "title" : "Namespacing"
        }
      },
      "add" : {
        "doc" : {
          "id" : 30,
          "author" : "http://eloquentjavascript.net/12_browser.html",
          "bibliography" : "The World Wide Web (not to be confused with the Internet as a whole) is a set of protocols and formats that allow us to visit web pages in a browser. The 'Web' part in the name refers to the fact that such pages can easily link to each other, thus connecting into a huge mesh that users can move through. To add content to the Web, all you need to do is connect a machine to the Internet, and have it listen on port 80, using the Hypertext Transfer Protocol (HTTP). This protocol allows other computers to request documents over the network.",
          "body" : "World Wide Web",
          "title" : "WWW"
        }
      },
    "commit" : { }
  }